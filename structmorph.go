package structmorph

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const tmpl = `// Code generated by structmorph; DO NOT EDIT.

package main

{{if ne .FromPkg "main"}}import "{{.FromPkgPath}}"{{end}}

func {{.FuncNameToDTO}}(src {{if ne .FromPkg "main"}}{{.FromPkg}}.{{end}}{{.From}}) {{.To}} {
	return {{.To}}{
		{{range .Fields}}{{.ToField}}: src.{{.FromField}},
		{{end}}
	}
}

func {{.FuncNameToStruct}}(src {{.To}}) {{if ne .FromPkg "main"}}{{.FromPkg}}.{{end}}{{.From}} {
	return {{if ne .FromPkg "main"}}{{.FromPkg}}.{{end}}{{.From}}{
		{{range .Fields}}{{.FromField}}: src.{{.ToField}},
		{{end}}
	}
}
`

type FieldMapping struct {
	FromField string
	ToField   string
}

type TemplateData struct {
	FuncNameToDTO    string
	FuncNameToStruct string
	FromPkg          string
	FromPkgPath      string
	From             string
	To               string
	Fields           []FieldMapping
}

func Generate(from, to string) error {
	fromPkg, fromStruct := parsePackageStruct(from)
	_, toStruct := parsePackageStruct(to)

	fromFile := findFileForStruct(fromStruct)
	slog.Info("Found file for struct", "struct", fromStruct, "file", fromFile)
	toFile := findFileForStruct(toStruct)
	slog.Info("Found file for struct", "struct", toStruct, "file", toFile)

	fFrom := parseFile(fromFile)
	fTo := parseFile(toFile)

	fromFields := extractStructFields(fFrom, fromStruct)
	slog.Info("Extracted fields for struct", "struct", fromStruct, "fields", fromFields)
	toFields := extractStructFields(fTo, toStruct)
	slog.Info("Extracted fields for struct", "struct", toStruct, "fields", toFields)

	validateFields(fromStruct, fromFields, toFields)

	fields := mapFields(toFields)

	fromPkgPath := getPkgPath(fromPkg, fromFile)

	data := TemplateData{
		FuncNameToDTO:    fmt.Sprintf("ConvertTo%s", toStruct),
		FuncNameToStruct: fmt.Sprintf("ConvertTo%s", fromStruct),
		FromPkg:          fromPkg,
		FromPkgPath:      fromPkgPath,
		From:             fromStruct,
		To:               toStruct,
		Fields:           fields,
	}

	return generateCode(data, fromStruct)
}

func parsePackageStruct(input string) (string, string) {
	parts := strings.Split(input, ".")
	if len(parts) != 2 {
		slog.Error("Invalid format for --from or --to. Expected 'package.StructName'", "input", input)
		os.Exit(1)
	}
	return parts[0], parts[1]
}

func findFileForStruct(structName string) string {
	var result string
	err := filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if strings.HasSuffix(path, ".go") && !info.IsDir() {
			slog.Info("Checking file", "file", path)
			fset := token.NewFileSet()
			f, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
			if err != nil {
				slog.Error("Error parsing file", "file", path, "error", err)
				return nil
			}
			structs := collectStructs(f)
			slog.Info("Found structs in file", "file", path, "structs", structs)
			if _, ok := structs[structName]; ok {
				slog.Info("Struct found in file", "struct", structName, "file", path)
				result = path
				return filepath.SkipDir
			}
		}
		return nil
	})
	if err != nil {
		slog.Error("Error walking file system", "error", err)
		os.Exit(1)
	}
	if result == "" {
		slog.Error("File containing struct not found", "struct", structName)
		os.Exit(1)
	}
	return result
}

func collectStructs(f *ast.File) map[string]struct{} {
	structs := make(map[string]struct{})
	for _, decl := range f.Decls {
		if g, ok := decl.(*ast.GenDecl); ok {
			for _, spec := range g.Specs {
				if t, ok := spec.(*ast.TypeSpec); ok {
					if _, ok := t.Type.(*ast.StructType); ok {
						structs[t.Name.Name] = struct{}{}
					}
				}
			}
		}
	}
	return structs
}

func parseFile(filename string) *ast.File {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, parser.AllErrors)
	if err != nil {
		slog.Error("Error parsing file", "file", filename, "error", err)
		os.Exit(1)
	}
	return f
}

func getPkgPath(pkg string, structFile string) string {
	if pkg == "main" {
		return ""
	}
	absPath, err := filepath.Abs(structFile)
	if err != nil {
		slog.Error("Error getting absolute path", "error", err)
		os.Exit(1)
	}
	// Get the current working directory
	projectRoot, err := os.Getwd()
	if err != nil {
		slog.Error("Error getting current working directory", "error", err)
		os.Exit(1)
	}
	// Convert the absolute path to import path by trimming the project root path
	importPath := strings.TrimPrefix(absPath, projectRoot+string(filepath.Separator))
	return filepath.ToSlash(importPath)
}

func extractStructFields(f *ast.File, structName string) map[string]string {
	fields := map[string]string{}
	for _, d := range f.Decls {
		if g, ok := d.(*ast.GenDecl); ok {
			for _, spec := range g.Specs {
				if t, ok := spec.(*ast.TypeSpec); ok && t.Name.Name == structName {
					if structType, ok := t.Type.(*ast.StructType); ok {
						for _, field := range structType.Fields.List {
							fieldName := field.Names[0].Name
							fieldType := fmt.Sprintf("%s", field.Type)
							fields[fieldName] = fieldType
						}
					}
				}
			}
		}
	}
	return fields
}

func validateFields(from string, fromFields, toFields map[string]string) {
	for fieldName, fieldType := range toFields {
		if fromFieldType, ok := fromFields[fieldName]; !ok || fromFieldType != fieldType {
			slog.Error("Field not found or type mismatch", "field", fieldName, "type", fieldType, "struct", from)
			os.Exit(1)
		}
	}
}

func mapFields(toFields map[string]string) []FieldMapping {
	fields := []FieldMapping{}
	for fieldName := range toFields {
		fields = append(fields, FieldMapping{
			FromField: fieldName,
			ToField:   fieldName,
		})
	}
	return fields
}

// todo refactor need to ability to change output path
func generateCode(data TemplateData, structName string) error {
	output, err := os.Create(fmt.Sprintf("%smorph.go", strings.ToLower(structName)))
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}
	defer output.Close()

	t := template.Must(template.New("morph").Parse(tmpl))
	err = t.Execute(output, data)
	if err != nil {
		return fmt.Errorf("error executing template: %w", err)
	}

	return nil
}
