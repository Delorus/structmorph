package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

const tmpl = `// Code generated by structmorph; DO NOT EDIT.

package main

func {{.FuncNameToDTO}}(src {{.From}}) {{.To}} {
	return {{.To}}{
		{{range .Fields}}{{.ToField}}: src.{{.FromField}},
		{{end}}
	}
}

func {{.FuncNameToStruct}}(src {{.To}}) {{.From}} {
	return {{.From}}{
		{{range .Fields}}{{.FromField}}: src.{{.ToField}},
		{{end}}
	}
}
`

type FieldMapping struct {
	FromField string
	ToField   string
}

type TemplateData struct {
	FuncNameToDTO    string
	FuncNameToStruct string
	From             string
	To               string
	Fields           []FieldMapping
}

func main() {
	if len(os.Args) < 2 {
		log.Fatalf("Usage: structmorph --from=Person --to=PersonDTO")
	}

	from := ""
	to := ""
	for _, arg := range os.Args[1:] {
		if strings.HasPrefix(arg, "--from=") {
			from = arg[len("--from="):]
		}
		if strings.HasPrefix(arg, "--to=") {
			to = arg[len("--to="):]
		}
	}

	if from == "" || to == "" {
		log.Fatalf("Usage: structmorph --from=Person --to=PersonDTO")
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "person.go", nil, parser.AllErrors)
	if err != nil {
		log.Fatalf("Error parsing file: %v", err)
	}

	fromFields, toFields := extractStructFields(f, from, to)
	validateFields(from, fromFields, toFields)

	fields := []FieldMapping{}
	for fieldName := range toFields {
		fields = append(fields, FieldMapping{
			FromField: fieldName,
			ToField:   fieldName,
		})
	}

	data := TemplateData{
		FuncNameToDTO:    fmt.Sprintf("ConvertTo%s", to),
		FuncNameToStruct: fmt.Sprintf("ConvertTo%s", from),
		From:             from,
		To:               to,
		Fields:           fields,
	}

	output, err := os.Create(fmt.Sprintf("%smorph.go", strings.ToLower(from)))
	if err != nil {
		log.Fatalf("Error creating output file: %v", err)
	}
	defer output.Close()

	t := template.Must(template.New("morph").Parse(tmpl))
	err = t.Execute(output, data)
	if err != nil {
		log.Fatalf("Error executing template: %v", err)
	}
}

func extractStructFields(f *ast.File, from, to string) (map[string]string, map[string]string) {
	fromFields := map[string]string{}
	toFields := map[string]string{}

	for _, d := range f.Decls {
		if g, ok := d.(*ast.GenDecl); ok {
			for _, spec := range g.Specs {
				if t, ok := spec.(*ast.TypeSpec); ok {
					if structType, ok := t.Type.(*ast.StructType); ok {
						if t.Name.Name == from {
							for _, field := range structType.Fields.List {
								fieldName := field.Names[0].Name
								fieldType := fmt.Sprintf("%s", field.Type)
								fromFields[fieldName] = fieldType
							}
						}
						if t.Name.Name == to {
							for _, field := range structType.Fields.List {
								fieldName := field.Names[0].Name
								fieldType := fmt.Sprintf("%s", field.Type)
								toFields[fieldName] = fieldType
							}
						}
					}
				}
			}
		}
	}

	return fromFields, toFields
}

func validateFields(from string, fromFields, toFields map[string]string) {
	for fieldName, fieldType := range toFields {
		if fromFieldType, ok := fromFields[fieldName]; !ok || fromFieldType != fieldType {
			log.Fatalf("Field %s with type %s not found in %s or types do not match", fieldName, fieldType, from)
		}
	}
}
